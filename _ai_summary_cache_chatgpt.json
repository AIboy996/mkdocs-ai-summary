{
    "mkdocs-ai-summary": {
        "content_md5": "1e4694ce248e7caf8eb4a9d3f3fa2b36",
        "ai_summary": "Mkdocs-ai-summary is a tool designed for users who need AI to summarize their words. Originally created for a blog site, it is now open to the public. The package is installed with pip, and currently supports only ChatGPT and Tongyi AI. To use these, an environmental variable must be set for the respective api key. Configuration options include api, model, ignore_code, cache, cache_dir, and prompt. Setup guides are provided for both ChatGPT and Tongyi AI summaries. There's also an option to setup ai summary for each page separately. The package comes with a cache function to prevent duplicate api calls. The function checks if the content has been summarized before and, if it hasn't changed, it uses the cache. The creators extend their thanks to projects like mkdocs and mkdocs-material."
    },
    "Example 3(tarnslated by ChatGPT summary)": {
        "content_md5": "458015aebe0c0a4a629a97cb9c121443",
        "ai_summary": "[[START]]\n    Until now, everything we've learned can be solved **in one sentence**. Whether it's function calls, variable assignments, or creating objects.\n\n    Next, we're going to learn **logical blocks composed of multiple lines**. To learn this content, we first introduce another important syntax in python \u2014 indentation (this is also one of the most common mistakes for newcomers)\n    ## Indentation\n    In python scripts, indentation has syntactic meaning, and it includes the logical structure of the code. Code with the same indentation is at the same level, the more indentation, the deeper the code level.\n\n    For example:\n\n    Regardless of how the `def` function is used, by looking at these two lines of code we can tell that `#!python print(\"hi\")` and `#!python print(\"hello world\")` both belong to the code inside `def`. And if we remove one of the indentations, the meaning of the code will be completely different:\n\n    It's not hard to understand that this code `#!python print(\"hi\")` is the subcode inside `def`, while `#!python print(\"hello world\")` and `def` are at the same level.\n\n    After understanding the meaning of indentation, let's learn how to indent. There are two common types of indentation:\n\n    - tab party\n    - space party\n\n    This is like the salty and sweet fans of tofu pudding, each has its supporters. I will only introduce the spacing method here. Theoretically, any number of spaces is legal indentation:\n    === \"1 space\"\n\n        \n    === \"2 spaces\"\n\n        \n    === \"3 spaces\"\n\n        \n    === \"4 spaces (recommended)\"\n\n        \n    But according to `PEP8` (Python Enhancement Proposal 8), we recommend using four spaces as one level of indentation.\n\n    ## User-defined functions\n    ### `def`\n    The format of the user-defined function has appeared in the previous text several times. Here is a more complex version:\n\n    We need to declare our function first with the `def` keyword, then a **space**, followed by the function's name and double brackets `()`. Inside the brackets, we write the parameters that the function can accept, and there can be multiple parameters.\n\n    Parameters can be used as variables within the function. When the function is called, the entered values \u200b\u200bare assigned to the corresponding variables and then all the contents of the function are executed in order. Please note that the space inside the function and the space outside are different namespaces, and the variables are not universal. Generally speaking, the inside can access the external variables, but the outside cannot access the internal variables.\n\n    Finally, use the `return` keyword to declare the return value of the function. After the function ends, this value will be returned. If there is no `return` statement, `None` will be returned, indicating that there is no return value.\n\n    The way to call a function is `()`, readers should be very familiar with it. And there are many ways to pass parameters to the function:\n\n    - Pass by position order: `f(1, 4)` is this usage\n    - Pass by name: `f(a=1, b=4)` This usage ignores position, e.g.: `f(b=4, a=1)`\n    - Mixed: `f(1, b=3)` Not recommended\n\n    Generally speaking, as long as it does not cause ambiguity, parameters can be passed in the order of positions.\n    ### `lambda`\n    Previous articles have also mentioned `the existence of unnamed functions`, and now we will introduce this so-called anonymous function.\n\n    The definition of an anonymous function is `lambda parameter : return value`, for example,\n\n    It will return a function that adds 2 to a number, and we can call this function directly:\n\n    > Please note that the brackets in `(lambda x : x+2)` represent a logical priority. Firstly execute the `lambda` statement to get a function object and then call it. This is similar to the round brackets in maths.\n\n    If you assign an anonymous function to a variable, then it can be used as a normal function:\n\n    Due to the simplicity of the anonymous function, we often use it as a parameter to pass to other functions:\n\n    > This also shows the representation of imaginary numbers in python: `1j`. Please note that you cannot replace `1j` with `j`, and `0` and `0j` are also not exactly the same. The former is an integer object and the latter is a complex object.\n\n    We will introduce more abundant function theories in the module of functional programming in advanced grammar.\n\n    ## User-defined classes\n    ### Process from class to object\n    The format of the user-defined class has also appeared in previous articles. Now let's add a `__new__` method to make the logic more comprehensive:\n    === \"Source code\"\n\n        \n    === \"Run result\"\n\n        \n\n    ??? question \"+= syntactic sugar\"\n        Careful readers will find that a symbol that has never been introduced before, `+=`, is used in the code above. In fact, this is one of python's syntactic sugars:\n\n        - Abbreviation: `a += b`\n        - Equivalent writing: `a = a + b`\n\n        Similarly, we also have `*=` , `/=` , `-=` , `//=` and `%=` .\n\n        Take this opportunity to supplement some previously missed content related to operators. In fact, these contents are relatively in line with daily use habits, so there is no need to waste too much ink:\n\n        - `+`: Addition operator, can also be a unary operator\n        - `-`: Subtraction operator, can also be a unary operator\n        - `/`: Division operator\n        - `*`: Multiplication operator\n        - `%`: Modulo operator\n        - `**`: Power operator\n        - `//`: Floor division operator, equivalent to division and then rounding down\n\n    First, look at the grammar. There are two levels of indentation involved here. The first level of indentation is under the `class` keyword, which represents the interior of class definition. The second level of indentation is under the `def` keyword, which represents the interior of class methods.\n\n    Next, pay attention that when defining the `__new__` method, we used a parameter `cls`, which is a parameter that python automatically passes in when creating an object. It represents **the class to be created**. The parameters of the class methods after the object is created can use a parameter `self`. This `self` parameter **does not need to be passed** when the method is actually called. Python will pass **the object itself** as the value of `self`. The positions and names of these two parameters are immutable. In addition, similar to the namespace inside functions, the namespace inside the class is also independent from the outside world.\n\n    Moreover, the return value of `__init__` function must be `None`, and the return value of `__new__` is `super().__new__(cls)`, which is to call the `__new__` method of the superclass (or parent class), and create a new object of `cls` class.\n\n    > If you do not specify to inherit a class, then the class created by python will automatically inherit from the `object` class, and the return value of `super()` is this inherited parent class.\n\n    Finally, from the output results, we can easily know the running process of the code:\n\n    1. Ran the `__new__` method and created an instance of the `Teacher` class.\n    2. Ran the `__init__` method and initialized its `age`\n    - In `#! wang = Teacher(20)`, the `__init__` method was called, and the `age` attribute of `wang` was assigned to `20`.\n    3. Printed the `age` attribute of `wang`.\n    4. Updated the age.\n    5. Printed the `age` attribute of `wang` after the update.\n\n    ### Inheritance of classes\n    This concept has been mentioned before. For convenience, sometimes we need a certain class to have all the attributes of another class, and then we can use class inheritance to achieve this. Here is a classic style:\n    === \"Source code\"\n\n        \n    === \"Run result\"\n\n        \n\n\n    In the above code example, the teacher class inherits from the human class (expressed as `Teacher(Person)`), but the teacher has one more attribute than humans: the course taught.\n\n    So we need to define the initialization function of the teacher class. But we don't want to write it all over again. So, we initially called the initialization function of the parent class: `super(Teacher, self).__init__` to complete the initialization content defined by the parent class, and then further initialized.\n\n    We can also know this process from the content of the printed text:\n\n    - First printed: `create a person with age  20`. This is the process defined in the parent class.\n    - Then printed: `seet lesson as  math`. This is the process defined in the subclass.\n\n    So far, the basic knowledge of the class has been introduced. The class is one of the most important, profound, and difficult contents in python and needs to be well understood. The above codes are all classic styles, and readers can follow these styles for practice.\n\n    We will introduce more class programming techniques in the Module of Object-Oriented Programming in the advanced tutorial.\n\n    ## `if` Conditional Statement\n    ### Boolean expressions\n    Before explaining the `if` conditional statement, we need to understand the Boolean (bool) expressions first.\n\n    `bool` is a class in python, which has only two values: `True` and `False`\n    > According to the help document: The builtins True and False are the only two instances of the class bool.\n\n    These two values represent truth and falsehood, which are similar to the true and false propositions in maths.\n\n    The so-called Boolean expression refers to an equation whose result is a Boolean value, such as:\n\n    - `1 == 2`\n    - `1 < 2`\n    - `1 is None`\n    - `any(...)` and `all(...)`\n\n    And so on.\n\n    ??? question \"Logical operators\"\n        The following logical operators are common in Boolean expressions:\n\n        - `is`: Judge whether two objects are the same object\n        - `not`: Taking the opposite\n        - `in`: Determine whether it belongs to\n        - `and`: Take the sum\n        - `or`: Take or\n        - `> `<` = `>=` <= `!=`: The last one is unequal, the others can be understood according to semantics\n\n        In fact, you can type `help(\"&\")` in python to get related information:\n        ??? question \"All operators\"\n            \n\n    ### The structure of `if` statement\n    Armed with the understanding of Boolean expressions, we can then write `if` conditional statements:\n\n    If you know that `elif` is an abbreviation for `else if`, then it is basically natural language. Nothing much to say.\n\n    `if` and `elif` must be followed by a Boolean expression, and then judge one by one. If it does not meet the requirements, enter the next option. If it meets, end this logical block. Before writing the `if` statement, you need to clarify the logical relationship. Knowing which to judge first and which to judge later is very important. If the above statement is changed to:\n\n    Although the results are correct, theoretically, it will be much slower than the previous writing because judging whether `a>1` can filter out half of the values \u200b\u200bon the number line, while judging `0 <= a <= 1` can only filter out the values \u200b\u200bbetween `[0,1]` on the number line. Which is better and which is inferior can be judged.\n    ??? info \"Learn about the situation in other languages\"\n        The `if` conditional statement is probably in any one programming language, but `elif` is probably a specialty of python, because it comes with python's indentation.\n\n        \n        Look, without `elif`, every time you want to use `else if` under python's indentation system, you need to indent it once. Once the logical structure is complex, the indentation will be very headache.\n\n        \n        Other languages\u200b\u200b (C and a bunch of programming languages \u200b\u200bwith similar C syntaxes) all have this pattern:\n\n        \n        I guess there is no need for `elif`.\n\n    What would be primarily addressed here is the `input` function, which can retrieve user input:\n    ![](./assets/input.png)\n\n    This function can be said to offer limitless possibilities for interaction.\n    ### Compact `if` statement\n    Sometimes `if` statements can be written in a compact form that is only one line long:"
    },
    "Example 1(ChatGPT summary with h1)": {
        "content_md5": "17ebb3f102f86b3ba232a8ece5f02504",
        "ai_summary": "This article covers a comprehensive explanation of various Python programming concepts, starting by highlighting the importance of indentation in Python for shaping the logic of the code, then introducing function definitions using the \"def\" keyword and different ways to pass arguments. It also explains anonymous functions defined by the \"lambda\" keyword. It further explores defining custom classes and process from a class to an object, the symbol \"+=\", overwriting methods and class inheritance. The article then explains Python's conditional statement \"if\" and the use of \"elif\". Proceeding further, it teaches about loop structures, particularly \"for\" and \"while\" loops, and using \"continue\", \"break\" and \"pass\" for loop control. Explaining how to use \"import\", the text then focuses on handling exceptions in Python, including the \"try-exception\", \"raise\", \"assert\" statements and generating custom exceptions. Please refer to the original text for comprehensive examples and detailed understanding."
    }
}