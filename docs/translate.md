---
tags:
- PyIntro
include:
- ai-summary
ai-summary-config:
    prompt: "Help me translate the content into English. Please keep all the markdown markers and delete all the words before [[START]]."
---

# Example 3(tarnslated by ChatGPT summary)

> copy from <https://yangzhang.site/Python/BasicSyntax/builtin_keyword/>, please check raw `.md` file.

??? quote

    [[START]]
    到目前为止，我们所学的内容都是**一句话**可以解决的。不论是函数调用，还是变量赋值抑或是创建对象。

    接下来我们就要学习**多行组成的逻辑块**。为了学习这个内容，我们先要介绍python中另外一个重要的文法——缩进（这也是新人最出错的地方之一）
    ## 缩进
    在python的脚本中，缩进是有语法涵义的，它蕴含了代码的逻辑结构。缩进规格相同的代码处于同一层级，缩进越多代码层级越深。

    例如：
    ```python
    def hello():
        print("hi")
        print("hello world")
    ```
    先不管`def`的用法如何，但看这两行代码我们就能知道`#!python print("hi")`和`#!python print("hello world")`是同属于`def`内部的代码。而如果去掉其中一个缩进，代码的意味就完全不同了：
    ```python
    def hello():
        print("hi")
    print("hello world")
    ```
    不难理解，这样的代码`#!python print("hi")`是`def`内部的子代码，而`#!python print("hello world")`和`def`处在同一层次。

    了解了缩进的意义之后，我们来学习缩进的方法。常见的缩进方法有两类：

    - tab党
    - space党

    这就好比豆腐脑儿的咸甜党，各有人拥护。我这里只介绍space，也就是空格的缩进方法。理论上不论是多少个空格都是合法的缩进：
    === "1空格"

        ```python 
        def hello():
        print("hi")
        ```
    === "2空格"

        ```python 
        def hello():
        print("hi")
        ```
    === "3空格"

        ```python 
        def hello():
        print("hi")
        ```
    === "4空格（推荐）"

        ```python 
        def hello():
            print("hi")
        ```
    但是按照`PEP8`（Python Enhancement Proposal 8）的建议，我们推荐使用4个空格来作为一层缩进。

    ## 自定义函数
    ### `def`
    自定义函数的格式前文已经多次出现了，这里给出一个更加复杂的版本：
    ```python
    def f(a, b):
        print(a, b)
        return a + b

    print(f(2, 1)) ## 返回值为3
    print(f(1, 4)) ## 返回值为5
    ```
    我们定义函数需要先用`def`关键字来声明，然后**空格**，写下函数的名字和双括号`()`，在括号内写函数可以传入的参数，参数可以有多个。

    参数可以作为函数内部的变量来使用，在函数被调用的时候会把传入的值赋值给对应的变量然后依次执行函数中所有的内容。请注意，函数内部的空间和外部的空间是不同的命名空间，变量并不通用。一般来说内部可以访问外部的变量，但是外部不可以访问内部的变量。

    最后用`return`关键字来声明函数的返回值，函数结束之后就会返回这个值。如果没有`return`语句，就会返回一个`None`，代表没有返回值。

    函数调用的方式是`()`，读者应该以及很熟悉。而函数传递参数的方式有很多种：

    - 按照位置顺序传递：`f(1, 4)`就是这种用法
    - 按照名字传递：`f(a=1, b=4)`这种用法可以无视位置，例如：`f(b=4, a=1)`
    - 混合：`f(1, b=3)`不推荐

    一般而言不引起歧义的时候都可以按照位置顺序来传递参数。
    ### `lambda`
    之前的文章中也提到过`存在没有名字的函数`，这里我们就来介绍一下所谓的匿名函数。

    匿名函数的定义方式为`lambda parameter : return value`，例如
    ```python
    lambda x : x+2
    ```
    就会返回一个函数，他的作用是把一个数字加上2，我们可以直接调用这个函数：
    ```python
    (lambda x : x+2)(3)
    # 返回值是5
    ```
    > 注意到上面的`(lambda x : x+2)`里的括号代表一种逻辑优先级，先执行`lambda`语句得到一个函数对象然后再调用，这和数学中的圆括号是类似的。

    而如果把匿名函数赋值给一个变量，那么就可以当作正常的函数来使用：
    ```python
    add = lambda x,y : x+y
    print(add(1, 2))  ## 打印出来的是3
    ```
    由于匿名函数的简洁，我们经常会把它作为一个参数传递到其他函数中：
    ```python title="列表中的元素按照实部大小升序排列"
    l = [1j, 2j+3, 1j, 3j+1]
    l.sort(key = lambda x:x.real)
    print(l) # 输出的值为 [1j, 1j, (1+3j), (3+2j)]
    ```
    > 这里也展示了python中虚数的表示方法：`1j`，请注意不能用`j`代替`1j`，并且`0`和`0j`也不完全相同，前者是整数对象，后者是复数对象。

    更加丰富的函数理论我们会在高级语法的函数式编程模块中介绍。

    ## 自定义类
    ### 从类到对象的过程
    自定义类的格式之前的文章也出现过，下面我们加上一个`__new__`方法，让逻辑更加完整：
    === "源代码"

        ```python
        class Teacher:
            """老师类"""
            def __new__(cls, age): ## 一般而言这个方法可以省略
                print("new")
                return super().__new__(cls)

            def __init__(self, age): ## 如果需要初始化对象，这个方法不可省略
                print("init")
                self.age = age

            def update_age(self):
                print("update age")
                self.age += 1

        wang = Teacher(20)
        print("老师现在的年龄: ", wang.age)
        wang.update_age()
        print("老师明年的年龄: ", wang.age)
        ```
    === "运行结果"

        ```text
        new
        init
        老师现在的年龄: 20
        update age
        老师明年的年龄: 21
        ```

    ??? question "+=语法糖"
        细心的读者会发现，上面的代码中使用了一个从未介绍过的符号`+=`。实际上这是python的语法糖之一：

        - 简写：`a += b`
        - 等价写法：`a = a + b`

        类似的我们还有`*=`，`/=`，`-=`，`//=`和`%=`。

        借此机会补充一下之前漏掉的运算符相关内容。实际上这些内容比较符合日常使用习惯，所以也不必浪费太多笔墨：

        - `+`：加法运算符，也可以作为一元运算符
        - `-`：减法运算符，也可以作为一元运算符
        - `/`：除法运算符
        - `*`：乘法运算符
        - `%`：模运算符
        - `**`：乘方运算符
        - `//`：地板除运算符，等价于除法然后向下取整


    首先看文法，这里涉及到了两层缩进。第一层缩进是`class`关键字下方，代表类定义的内部。第二层缩进是`def`关键字下方，代表类方法的内部。

    其次注意到，我们定义`__new__`方法的时候使用了一个参数`cls`，它是python在创建对象的时候自动传入的参数，代表**要创建的类**。对象创建完毕后的类方法都可以使用一个参数`self`，这个self参数在实际方法调用的时候**无需传递**，python会把**对象本身**作为`self`的值传递进来。这两个参数的位置和名称都是不可变动的。另外和函数内部命名空间类似，类内部的命名空间也是自成一体的，和外部相对独立。

    再次，`__init__`函数的返回值必须是`None`，而`__new__`的返回值为`super().__new__(cls)`，实际上就是调用了超类（或者叫父类）的`__new__`方法，新建了一个`cls`类的对象。

    > 如果不指定继承某个类，那么python新建的类会自动继承自`object`类，而`super()`的返回值就是这个被继承的父类

    最后我们通过输出的结果不难得知代码的运行过程：

    1. 运行了`__new__`方法，创建了`Teacher`类的一个实例
    2. 运行了`__init__`方法，初始化它的`age`
    - 在`#! wang = Teacher(20)`中就调用了`__init__`方法，把`wang`的`age`属性赋值为`20`
    1. 打印了`wang`的`age`属性
    2. 更新了年龄
    3. 打印了更新后`wang`的`age`属性



    ### 类的继承
    之前也提过这个概念，方便起见我们有时需要让某个类具有另外一个类的全部属性，那么就可以用类的继承来实现。例如下面的经典写法：
    === "源代码"

        ```python
        class Person:
            """人类"""
            def __init__(self, age):
                print("create a person with age ", age)
                self.age = age
            
            def update_age(self):
                print("update age")
                self.age += 1

        class Teacher(Person): ## 继承关系用()来表示
            """老师类"""
            def __init__(self, age, lesson):
                super(Teacher, self).__init__(age)
                print("set lesson as ", lesson)
                self.lesson  = lesson

        wang = Teacher(20, 'math')
        print("老师现在的年龄：", wang.age)
        print("老师教授的科目：", wang.lesson)
        wang.update_age()
        print("老师明年的年龄：", wang.age)
        ```
    === "运行结果"

        ```text
        create a person with age  20
        seet lesson as  math
        老师现在的年龄： 20
        老师教授的科目： math
        update age
        老师明年的年龄： 21
        ```


    上面的代码示例中，老师类继承了人类（表示方法为`Teacher(Person)`），但是老师比人多出来一个属性：教授的课程。

    于是我们需要定义老师类的初始化函数。但是又懒得完全重新写一次，于是先调用了父类的初始化函数：`super(Teacher, self).__init__`，完成父类定义的初始化内容，然后再进行进一步的初始化。

    这个过程通过打印出来的文字内容也可以获悉：

    - 先打印了：`create a person with age  20`，这是父类中定义的过程
    - 然后打印了：`seet lesson as  math`，这是子类中定义的过程

    至此，较为基础的类的知识就介绍完成了。类是python中最重要也是最深刻、最困难的内容之一，需要好好理解。上面的代码都是经典的写法，读者可以效仿这些写法进行练习。

    更多的类编程的技术我们会在高级教程的面向对象编程模块介绍。

    ## `if`条件语句
    ### 布尔表达式
    在讲解`if`条件语句之前，我们得先来了解布尔（bool）表达式。

    `bool`是python中的一个类，他有且仅有两个值：`True`和`False`
    > help文档中的说法是：The builtins True and False are the only two instances of the class bool.

    这两个值分别代表真伪，这就类似于数学中的真假命题。

    所谓的布尔表达式指的是结果为布尔值的算式，例如：

    - `1 == 2`
    - `1 < 2`
    - `1 is None`
    - `any(...)`和`all(...)`

    等等。

    ??? question "逻辑运算符"
        在布尔表达式中常见以下的逻辑运算符：
        
        - `is`：判断两个对象是否为同一个对象
        - `not`：取否
        - `in`：判断是否属于
        - `and`：取和
        - `or`：取或
        - `>` `<` `=` `>=` `<=` `!=`：最后一个是不等于，其他按照语义理解即可

        实际上你可以在python中输入`help("&")`来获取相关信息：
        ??? question "所有的operator"
            ```
            +-------------------------------------------------+---------------------------------------+
            | Operator                                        | Description                           |
            |=================================================|=======================================|
            | "(expressions...)",  "[expressions...]", "{key: | Binding or parenthesized expression,  |
            | value...}", "{expressions...}"                  | list display, dictionary display, set |
            |                                                 | display                               |
            +-------------------------------------------------+---------------------------------------+
            | "x[index]", "x[index:index]",                   | Subscription, slicing, call,          |
            | "x(arguments...)", "x.attribute"                | attribute reference                   |
            +-------------------------------------------------+---------------------------------------+
            | "await x"                                       | Await expression                      |
            +-------------------------------------------------+---------------------------------------+
            | "**"                                            | Exponentiation [5]                    |
            +-------------------------------------------------+---------------------------------------+
            | "+x", "-x", "~x"                                | Positive, negative, bitwise NOT       |
            +-------------------------------------------------+---------------------------------------+
            | "*", "@", "/", "//", "%"                        | Multiplication, matrix                |
            |                                                 | multiplication, division, floor       |
            |                                                 | division, remainder [6]               |
            +-------------------------------------------------+---------------------------------------+
            | "+", "-"                                        | Addition and subtraction              |
            +-------------------------------------------------+---------------------------------------+
            | "<<", ">>"                                      | Shifts                                |
            +-------------------------------------------------+---------------------------------------+
            | "&"                                             | Bitwise AND                           |
            +-------------------------------------------------+---------------------------------------+
            | "^"                                             | Bitwise XOR                           |
            +-------------------------------------------------+---------------------------------------+
            | "|"                                             | Bitwise OR                            |
            +-------------------------------------------------+---------------------------------------+
            | "in", "not in", "is", "is not", "<", "<=", ">", | Comparisons, including membership     |
            | ">=", "!=", "=="                                | tests and identity tests              |
            +-------------------------------------------------+---------------------------------------+
            | "not x"                                         | Boolean NOT                           |
            +-------------------------------------------------+---------------------------------------+
            | "and"                                           | Boolean AND                           |
            +-------------------------------------------------+---------------------------------------+
            | "or"                                            | Boolean OR                            |
            +-------------------------------------------------+---------------------------------------+
            | "if" – "else"                                   | Conditional expression                |
            +-------------------------------------------------+---------------------------------------+
            | "lambda"                                        | Lambda expression                     |
            +-------------------------------------------------+---------------------------------------+
            | ":="                                            | Assignment expression                 |
            +-------------------------------------------------+---------------------------------------+
            ```

    ### `if`语句的结构
    了解了布尔表达式之后我们就可以来写`if`条件语句了：
    ```python
    a = float(input("输入一个数字："))
    if a>1:
        print("大于1")
    elif a<0:
        print("小于0")
    else:
        print("0-1之间")
    ```
    如果知道了`elif`就是`else if`的简写，那基本就是自然语言了，没啥好说的。

    `if`和`elif`后面需要跟着一个布尔表达式，然后就是挨个判断，如果不满足就进入下一个选项，如果满足就结束掉这个逻辑块。写`if`语句之前需要理清楚逻辑关系，先判断哪个后判断哪个很重要。如果把上面的语句改成：
    ```python
    if a>=0 and a<=1:
        print("[0,1]")
    elif a>1:
        print(">1")
    else:
        print("<1")
    ```
    结果上都是正确的，但是理论上来说会比前面的写法慢上很多。因为判断`a>1`与否可以过滤掉数轴上一半的值，而判断`0<=a<=1`则只能过滤掉数轴上`[0,1]`的值，孰优孰劣高下立判。
    ??? info "了解一下其他语言的情况"
        if条件句大概是任何一门编程语言都有的，但是`elif`大概是python的特产，因为它是python的缩进带来的。

        ```python
        if a:
            pass
        else:
            if b:
                pass
            else:
                if c:
                    pass
                else:
                    pass
        ```
        你看，如果没有`elif`在python的缩进体系下，每次想使用`else if`都需要缩进一次，一旦逻辑结构比较复杂，缩进就非常让人头疼了。
        
        其他语言（C和类C语法的一大堆编程语言）都是这种造型：

        ```java
        if( x == 10 ){
            System.out.print("Value of X is 10");
        }else if( x == 20 ){
            System.out.print("Value of X is 20");
        }else if( x == 30 ){
            System.out.print("Value of X is 30");
        }else{
            System.out.print("这是 else 语句");
        }
        ```
        大概也就不需要`elif`了。

    这里主要来介绍一下`input`函数，它可以获取用户的输入：
    ![](./assets/input.png)

    可以说这个函数提供了无穷的可玩性。
    ### 紧凑型的`if`语句
    某些时候`if`语句可以写成只有一行的紧凑形式：
    ```python
    abs_of = lambda x: x if x>0 else -x
    ```